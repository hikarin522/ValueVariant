<#@ template language="C#" hostspecific="false" linePragmas="false" #>
<#@ output extension=".tt.cs" encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../Const.t4" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY ValueVariantT.ActionVisitor.tt. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable

using System.Runtime.CompilerServices;

using V2 = ValueVariant;

namespace ValueVariant.Details;
<# for (var i = 1; i <= MaxTypeParam; ++i) { #>

partial class ValueVariant<<#= Join(1, i, e => $"T{e}") #>>
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void AcceptActionVisitor<T, V>(in T @this, in V visitor)
		where T: unmanaged, V2.IValueVariant<T, <#= Join(1, i, e => $"T{e}") #>>
		where V: <#= Join(1, i, e => $"IValueVariantActionVisitor<T{e}>") #>
	{
		switch (@this.TypeIndex) {
<#   for (var j = 1; j <= i; ++j) { #>
			case <#= j #>: visitor.Visit(@this.Item<#= j #>); return;
<#   } #>
			default: Throw.InvalidOperationException(); return;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void AcceptActionVisitor<T, V, TA1>(in T @this, in V visitor, TA1 arg1)
		where T: unmanaged, V2.IValueVariant<T, <#= Join(1, i, e => $"T{e}") #>>
		where V: <#= Join(1, i, e => $"IValueVariantActionVisitor<T{e}, TA1>") #>
	{
		switch (@this.TypeIndex) {
<#   for (var j = 1; j <= i; ++j) { #>
			case <#= j #>: visitor.Visit(@this.Item<#= j #>, arg1); return;
<#   } #>
			default: Throw.InvalidOperationException(); return;
		}
	}
}
<# } #>
