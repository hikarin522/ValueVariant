<#@ template language="C#" linePragmas="false" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="ValueVariant" #>
<#@ include file="../Const.t4" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY ValueVariant.Generator. DO NOT CHANGE IT.
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>
using MessagePack;
using MessagePack.Formatters;

<# } #>
#if NETCOREAPP2_1_OR_GREATER
using System.Diagnostics.CodeAnalysis;

#nullable enable
#endif

namespace <#= Namespace #>
{
    using V2 = global::ValueVariant;

    using T = global::<#= FullName #>;

<# for (var i = 1; i <= Count; ++i) { #>
    using T<#= i #> = global::<#= Types[i - 1] #>;
<# } #>

<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>
    [MessagePackFormatter(typeof(<#= TypeName #>.MessagePackFormatter))]
<# } #>
    readonly partial struct <#= TypeName #> : IEquatable<T>,
        <#= Join(1, Count, e => $"V2.Details.IValueVariantElement<T{e}>") #>
    {
        [StructLayout(LayoutKind.Explicit)]
        private readonly struct Union
        {
<# for (var i = 1; i <= Count; ++i ) { #>
            [FieldOffset(0)] internal readonly T<#= i #> Item<#= i #>;
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
            internal Union(T<#= i #> value) : this() => this.Item<#= i #> = value;
<# } #>
        }

        public enum TypeIndex : byte { None, <#= Join(1, Count, e => $"Type{e}") #> }

        private readonly Union Value;

        public readonly TypeIndex Index;

        byte V2.Details.IValueVariant.TypeIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => (byte)this.Index; }

        private <#= TypeName #>(in Union value, TypeIndex index)
            => (this.Value, this.Index) = (value, index);

<# for (var i = 1; i <= Count; ++i ) { #>
        public <#= TypeName #>(T<#= i #> value) : this(new Union(value), TypeIndex.Type<#= i #>) { }
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
        public T<#= i #> Item<#= i #> { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => this.Index == TypeIndex.Type<#= i #> ? this.Value.Item<#= i #> : ThrowInvalidCastException<T<#= i #>>(); }
<# } #>

#if NETSTANDARD2_1_OR_GREATER
        [DoesNotReturn]
#endif
        private static TV ThrowInvalidCastException<TV>() => throw new InvalidCastException();

<# for (var i = 1; i <= Count; ++i ) { #>
        public static implicit operator T(T<#= i #> value) => new T(value);
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
        public static explicit operator T<#= i #>(in T value) => value.Item<#= i #>;
<# } #>

        public bool Equals(T other)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.Equals(this, other);

#if NETCOREAPP2_1_OR_GREATER
        public override bool Equals([NotNullWhen(true)] object? obj)
#else
        public override bool Equals(object obj)
#endif
            => obj is T other && this.Equals(other);

        public static bool operator ==(in T lhs, in T rhs)
            => lhs.Equals(rhs);

        public static bool operator !=(in T lhs, in T rhs)
            => !lhs.Equals(rhs);

        public override int GetHashCode()
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.GetHashCode(this);

        public override string ToString()
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.ToString(this);

        public interface IActionVisitor : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}>") #> { }

        public interface IActionVisitor<in TA1> : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}, TA1>") #> { }

        public interface IFuncVisitor<out TR> : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TR>") #> { }

        public interface IFuncVisitor<in TA1, out TR> : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TA1, TR>") #> { }

        public TR Accept<TR>(IFuncVisitor<TR> visitor)
        {
            this.Accept(visitor, out TR result);
            return result;
        }

        public TR Accept<TA1, TR>(IFuncVisitor<TA1, TR> visitor, TA1 arg1)
        {
            this.Accept(visitor, arg1, out TR result);
            return result;
        }

        public void Accept<TV>(in TV visitor)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}>") #>
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptActionVisitor(this, visitor);

        public void Accept<TV, TA1>(in TV visitor, TA1 arg1)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}, TA1>") #>
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptActionVisitor(this, visitor, arg1);

        public void Accept<TV, TR>(in TV visitor, out TR result)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TR>") #>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptFuncVisitor<T, TV, TR>(this, visitor);

        public void Accept<TV, TA1, TR>(in TV visitor, TA1 arg1, out TR result)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TA1, TR>") #>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptFuncVisitor<T, TV, TA1, TR>(this, visitor, arg1);

        public void Accept(V2.IValueVariantGenericActionVisitor visitor)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericActionVisitor(this, visitor);

        public void Accept<TA1>(V2.IValueVariantGenericActionVisitor<TA1> visitor, TA1 arg1)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericActionVisitor(this, visitor, arg1);

        public TR Accept<TR>(V2.IValueVariantGenericFuncVisitor<TR> visitor)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericFuncVisitor<T, V2.IValueVariantGenericFuncVisitor<TR>, TR>(this, visitor);

        public TR Accept<TA1, TR>(V2.IValueVariantGenericFuncVisitor<TA1, TR> visitor, TA1 arg1)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericFuncVisitor<T, V2.IValueVariantGenericFuncVisitor<TA1, TR>, TA1, TR>(this, visitor, arg1);

        public abstract class DefaultConverter<TConverter> : IFuncVisitor<T>
            where TConverter : DefaultConverter<TConverter>, new()
        {
            public static TConverter Instance { get; } = new TConverter();

<# for (var i = 1; i <= Count; ++i ) { #>
            public T Visit(in T<#= i #> value) => value;
<# } #>
        }

        public sealed class DefaultConverter : DefaultConverter<DefaultConverter> { }
<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>

        private sealed class MessagePackFormatter : IMessagePackFormatter<T>
        {
            public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
            {
                options.Resolver.GetFormatterWithVerify<byte>().Serialize(ref writer, (byte)value.Index, options);
                switch (value.Index) {
                    case TypeIndex.None: return;
<#   for (var i = 1; i <= Count; ++i) { #>
                    case TypeIndex.Type<#= i #>: options.Resolver.GetFormatterWithVerify<T<#= i #>>().Serialize(ref writer, value.Item<#= i #>, options); return;
<#   } #>
                    default: throw new InvalidOperationException();
                }
            }

            public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                var index = (TypeIndex)options.Resolver.GetFormatterWithVerify<byte>().Deserialize(ref reader, options);
                switch (index) {
                    case TypeIndex.None: return default(T);
<#   for (var i = 1; i <= Count; ++i) { #>
                    case TypeIndex.Type<#= i #>: return new T(options.Resolver.GetFormatterWithVerify<T<#= i #>>().Deserialize(ref reader, options));
<#   } #>
                    default: throw new InvalidOperationException();
                }
            }
        }
<# } #>
    }
}
